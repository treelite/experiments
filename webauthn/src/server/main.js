import express from "express";
import ViteExpress from "vite-express";
import { randomUUID, createVerify, createHash } from "node:crypto";
import { Writable } from "node:stream";

const app = express();

const challenges = [];

const store = [];

/**
 * A buffer receiver to wait all data
 */
class BufferReceiver extends Writable {
  constructor() {
    super();
    this.chunks = [];
  }

  _write(chunk, _encoding, callback) {
    this.chunks.push(chunk);
    callback();
  }

  wait() {
    const chunks = this.chunks;
    return new Promise((resolve, reject) => {
      this.on("finish", () => {
        resolve(Buffer.concat(chunks));
      });
      this.on("error", (e) => {
        reject(e);
      });
    });
  }
}

const SPLITER = "\n".charCodeAt(0);
/**
 * Split one buffer to multiple buffers by the spliter
 */
const splitBuffer = (buffer, spliter = SPLITER) => {
  const res = [];
  let tmp = [];
  for (const value of buffer) {
    if (value !== spliter) {
      tmp.push(value);
    } else {
      res.push(Buffer.from(tmp));
      tmp = [];
    }
  }
  if (tmp.length > 0) {
    res.push(Buffer.from(tmp));
  }
  return res;
};

const decodeUTF8 = (data) => {
  const decoder = new TextDecoder("utf-8");
  return decoder.decode(data)
}

/**
 * Verify the clientData
 * check the operation type and challenge
 *
 * @param {Buffer} rawClientData
 * @param {string} type - Operation type, either "webauthn.create" or "webauthn.get"
 * @return {string | undefined} Error message
 */
const verifyClientData = (rawClientData, type) => {
  const clientData = JSON.parse(decodeUTF8(rawClientData));
  const challenge = challenges.pop();
  // The challenge from clientData is base64 encoded
  // https://www.w3.org/TR/webauthn-3/#client-data
  if (challenge !== atob(clientData.challenge)) {
    return "invalid challenge";
  } else if (clientData.type !== type) {
    return "incorrect operation";
  }
};

const queryStore = ({ id, name }) => store.find((item) => {
  if (id) {
    return item.id.equals(id);
  }

  if (name) {
    return item.name === name;
  }

  return false;
});

/**
 * Generate random challenge
 */
app.get("/challenge", (_, res) => {
  const challenge = randomUUID();
  challenges.push(challenge);
  res.send(challenge);
});

/**
 * Save credential
 */
app.put("/credential", async (req, res) => {
  const bufferReceiver = new BufferReceiver();
  req.pipe(bufferReceiver);
  const data = await bufferReceiver.wait();
  const [rawName, id, clientData, publicKey] = splitBuffer(data);
  const errorMsg = verifyClientData(clientData, "webauthn.create");
  if (!!errorMsg) {
    res.status(400).send(errorMsg);
    return;
  }

  const name = decodeUTF8(rawName);
  if (queryStore({ name })) {
    res.status(400).send("duplicated registration");
    return;
  }

  store.push({
    name,
    id,
    publicKey,
  });

  res.sendStatus(200);
});

/**
 * Query credential id based on the name
 */
app.get("/credential-id", async (req, res) => {
  const { name } = req.query;
  const record = queryStore({ name });
  if (!record) {
    res.sendStatus(404);
    return;
  }

  res.status(200).send(record.id);
});

/**
 * Authorize
 * verify the signature generated by the authenticator
 */
app.post("/authorize", async (req, res) => {
  const bufferReceiver = new BufferReceiver();
  req.pipe(bufferReceiver);
  const data = await bufferReceiver.wait();
  const [id, signature, authenticatorData, clientData] = splitBuffer(data);
  const errorMsg = verifyClientData(clientData, "webauthn.get");
  if (!!errorMsg) {
    res.status(400).send(errorMsg);
    return;
  }

  const record = queryStore({ id });
  if (!record) {
    res.status(400).send("invalid id");
    return;
  }

  // The signature is generated based on
  // authenticatorData + hash(clientData)
  // https://www.w3.org/TR/webauthn-3/#fig-signature
  //
  // Meanwhile SHA-256 is used to hash the clientData
  // https://www.w3.org/TR/webauthn-3/#collectedclientdata-hash-of-the-serialized-client-data
  const hash = createHash("sha256");
  hash.update(clientData);
  const clientDataHash = hash.digest();

  // The ES256 is used in this demo
  // therefore, SHA-256 is the required hash algorithm to verify the signature
  // also no need to the specify the signature algorithm as the public key contains information(SPKI)
  // that can be used to determine ECDSA signature algorithm
  const verify = createVerify("sha256");
  const source = Buffer.concat([authenticatorData, clientDataHash]);
  verify.update(source);
  // The publick key returned from `getPublicKey` is encoded as the the SubjectPublicKeyInfo of DER.
  // the default format of `verify` function is PEM, therefore an explicit "der" format and "spki" type are required here
  //
  // https://www.w3.org/TR/webauthn-3/#dom-authenticatorattestationresponse-getpublickeyk
  // https://gist.github.com/philholden/50120652bfe0498958fd5926694ba354
  if (verify.verify({ key: record.publicKey, format: "der", type: "spki"}, signature)) {
    res.sendStatus(200);
  } else {
    res.sendStatus(401);
  }
});

ViteExpress.listen(app, 3000, () =>
  console.log("Server is listening on port 3000...")
);
